---
talk_id: a-unified-styling-language
---

>> Our next speaker, Mark, is a fellow Australian, so watch out. One of these Australian high-five - it is more powerful and relational. He is a member of the Melbourne CSS community, organises MelbJS meet-up. I think he's going to bring a lot to the table today. We've got glen speaking up later as well, so we've got good Australian representation, which makes me proud. I was looking at the maps where Australia sat in there, and there was one moment - our internet is not that good, like a search from the 1960s, I would say. It was for the terracotta soldiers and the National Graphic for the soldiers came up. Anyway, Mark. [Applause].
MARK:  As you heard, my name is Mark Dalgleish, I'm all the way here from Melbourne, Australia. Believe it or not, my clicker isn't working - yes it is. I've been working in the web since 1999 when I got my start with HTML and soon after, CSS. It goes without saying, given I'm here, I really love CSS. I've been a big part of the React community in the last few years. I'm a fan of the React model and what it allows us to do with our products. Out of the React community came the work of CSS module which many of you are familiar with. It is a popular alternative to CSS and JS. It brings the component-scoping model to CSS, and, given that you might be surprised that I'm not actually here today to talk about CSS modules, I am here today to talk to you about CSS and JS. Please don't all leave immediately!  CSS and JS, even though I don't use it in my own work, is a really interesting thing to look at.
What I find frustrating is being part of the React community and seeing this work, often what is said to these people is that they should just learn CSS, they're just avoiding, they want  they want to do everything in JavaScript. At the core this is a separation here going on, I think, that people think is there. But for me, it is not there. I'm a big part of of the React community, as I said, and I love component systems, but I've been around the web for a lock time and I'm a big fan of progressive enhancement which brought me to React in the first place. I bring this into my own work. This is a video of what I've been working on in the past few years in Melbourne at Seek, the leading job site. You see a single-page app built in React, it is responsive, fast, hitting APIs and rendering in your browser. The catch is everything here is I disabled JavaScript in my browser. Despite being a single-page app written in JavaScript, you can run it without JavaScript. That's what React allows us to do. So I'm very interested in CSS and JS. Again, even though I'm not using it in my own work, I'm keeping a close eye on it. I think you should be too. That's the important point. I think that's why I'm here today. But why?  Why are people doing this at General why should you be interested as well?  There are five key reasons I want to cover today. There's more to it than this, but these are the practical benefits you get from taking on this approach, and even if you're not going to bring this into your own work, it will help you get a sense of why people are doing something that seems maybe ridiculous from the outside. We will look at scope styles, critical CSS, smarter optimisations, package management and finally, non-browser styling. So the first one is scope styles. Now, I guess I don't have to convince you of the fact that managing CSS at scale is really hard. So much so that I say that it's the hardest problem in front-end, because if you think about working with multiple people on a large project over a long period of time, if you don't have much structure, what's the technology that goes downhill the fastest and becomes unmaintainable?  It's CSS. That's something that the CSS community has known for a long time, and we've been working hard to solve it. The big entries in this are  is CSS from Nicole O'Sullivan. We've got SMACSS and from Jonathan, and we've also got BEM from Yandex which to me seems to be the most popular in the wild. BEM is a naming convention for your classes that I'm sure you're all familiar with, but at the end of the day, BEM is a convention, nothing stopping you writing your classes in a BEM style at any given moment, but even so, it is a fantastic way to manage complexity at scale in our code basis. I would say if you're working in CSS at scale, an approach like this is invaluable. If it is so central to managing CSS at scale well, why is it in the convention?  This is something I wrestled with heavily. When you look at it closely, particularly in a component system, BEM blocks are essentially components, it is the same obstruction. When you're working with a single-page framework or library like React, your components are defined in JavaScript, so having your CSS follow the same scoping rules as your components is really valuable. What we are going to do from now is take a quick look at a library that does this. It is Glamour. And basically what it does is it allows you to define your CSS in JavaScript, but the key thing is that whenever you define a set of rules like this, it generates a class for you automatically, so that means that you don't have to worry about scoping it in a global namespace - that's handled for you. So the harsh in classes is done for you - so the hash is done for you rather than forcing it in hand. One of the things I have to address early on - the elephant in the room - these libraries, or the most recent ones, they don't do inline styles. They are all about generating real CSS and inserting it into the document - exactly what you would have written by hand.
Another entry in the CSS and JS space is JSS by Oleg, here in Berlin, but like I said, because it is not inline styles, it is real CSS would be we can add hover stylings and media queries and these will work in the way you expect. When you attach these styles to the document, that's the moment at which it hands the classes to you, so now you have a reference to those classes. And when you insert some mark-up into the document, whether it's by some fancy framework, or even just in HTML, you can now interplate those classes into the HTML like so. So here our class is classes.heading generated by a string in the library, not by us. So scope CSS is about scoping to components. This is why you see the work coming out of the React community in similar libraries, so much so that there are often bindings for the library like React.css. We are injecting the styles in the component, and within the component, we have  we have access to the classes. In a sense what we are doing is generating a little style sheet for every single component. If you're looking at this and wondering what about separating concerns?  Do I have to put my styles in the same file as my JavaScript as my components?  Even though a lot of people do, there's nothing stopping you from architecting your app differently. You can extract your files in a different - styles in a different file and export them. What you're doing is making an explicit reference from where you define the styles to where you use them. The maintainability of your styles is greatly increased at this point. What is important here is your styles are now passed around like regular code. It is not something that sits in the global scope implicitly. It is something that you have to hand around your application to the components that need it. Component-scoping is now automated for us. This is the basis of working in an environment like atomic design where it is all about components all the way down, and to do this at scale effectively with multiple people, we need to scope our CSS. The keying here is that BEM, best practice in the CSS community, is now baked in. It is not opt-in, not something you have to remember to do, it is done for you. Now, at this point you might be looking at it and thinking if you're familiar with CSS modules, that's exactly what it does for you. That's right. If that is all you want, CSS modules will do that for you and it's really great. But another feature came along that people are expecting with that really opened my eyes to the possibility of doing styles in JavaScript and that is critical CSS. Patrick's already covered a little bit of this earlier today, but just for a quick recap, this is something that Google page speed have been talking about for a while now. They are recommending that you do in your applications. That's inlining styles for the current page in the head of the document to improve that initial rendering indeed. So, it looks something like this as we've seen before. You're inlining the styles that are relevant to this page in the head and then the rest of your style sheet can self-sit at the - can safely sit at the bottom of the page. There's some really great tooling out there for automating this. There's a program called Critical, and it's really great to do this of course for obvious reasons - speeding up the initial render - but the problem is first of all it's an optional optimisation, it's something you have to add in later. As Patrick said as well, it is hard to maintain and it's hard to automate, and I completely agree with this. It is quite a heavyweight system, powered by phantom JS, not something you want to do on every request on the server, for example,. If you look at CSS and JS in a server-rendered environment, it is the complete opposite. With CSS and JS it's not just an optimisation, it depends on CSS to work. The good of this is the library after ... but what I want you to pay attention  attention to is inside the rendering function for that heading component, every time we are heading our styles, we are wrapping them - this function is allowing Aphrodite to keep track of every style being used at any moment in time, so, if you do a full render of the application Aphrodite knows which styles you do need and which you don't need. That means on a server, when you're rendering server side for every request, you can hook into Aphrodite and render your application to a string and part of that is getting both the HTML and the CSS for that render. So now getting the critical CSS is automated for us on every render. Here we are generating a string of a style tag and inside of it we are inserting the CSS content that was generated for us by Aphrodite. If you've worked with React on the server and seen how it works before, you'll see this is familiar because it is what it does with React as well. Even though React runs on the browser, we can run it on the server, and all - so now we have static HTML and static CSS. So the key thing here is that even though we are defining everything in JavaScript, you might think that JavaScript is required but this is built for progressive enhancement. The browser can completely shut off JavaScript and things will still work as expected.  So, even if you're server-rendered, and statically rendered for HTML and even for simple letter static sites we can render the same components and render HTML in CSS. There is a theme here of the best practice of critical CSS is built-in, it's not opt-in when you work in this environment.
The third point I want to cover is smarter optimisations based on the fact that CSS and JS has better integration with your mark-up. In the CSS there's been focus on how do reduce our bundle to the minimum. As we produce more styles, the style sheets grow larger over time. How do we deal with that?  There's been interesting work from Yahoo and atomic success. They use a controversial function called style syntax from their classes and from this they can use some tooling to generate a style sheet for you. There's tacky-ones that does something similar. It is a more opinionated framework style and it gives you a suite to apply. Once you get familiar with the library, you would be able to read these of course. The key idea they are pushing here is they are treating classes like inline styles to try and reduce the CSS in that final bundle. To me, this one is a little bit of a mixed bag in the sense that I value the output - I think it is worth trying to cut down the CSS bundle - but it comes at quite a cost at development time. You have to buy into a framework or use an obscure syntax and these sorts of things are hard to use in a team environment where maybe not everyone's familiar and not everyone is bought in, so I'm not so sure on this one if you look at how CSS and JS works and CSS modules as well, you never hard-code a string to a class. It is always a reference to a string that is provided to you either from the library or from the tooling. Here we are saying this eye side using the styles.side class. Because it is a reference to a spring it might refer to a side bar. For all we know, it could be made up of several classes. It is not out of our control, it is the tooling that takes care of this for us. That opens up some really interesting possibilities. The perfect example of this is a really great library is called Style Tron. This shows me where we can start to do radically good things when we blur the lines between CSS and JavaScript, because what it brings to the table is dynamic zero config atomic CSS - all the benefits of reducing that final payload - without the development time costs, without having to buy into a framework in the same way.
So what I want to show you here is what it kind of looks like in practice. So, on the left there, what you've got is three different sets of rules being defined, and, on the right there, you've got the final generated CSS. The first thing you will notice is that the generated CSS is half the size, and why is that?  It is because there is a lot of repetition going on.  So font size is in the first and the last one. A height of 2 pixels is in the top and - a height of 32 pixels is in the rules and - that means in effect we've really only got three unique combinations so we only need three classes. This is something that style tron can take care of for us automatically by generating these virtual class strings in the middle, so you notice we've got classes of AB, AC, BC encapsulating what is in common between these different styles for us, so that atomic CSS styles string can be actually be generated for us. In code what that looks like at its lowest level is style tron gives us an API to inject a media query - this is generating real CSS, and for this what we get is the class A. This is the first class we've generated.
So once we start to generate classes from multiple rules, what we will start to see is what we saw before, so here the colour red is used in both the first and second sets so we get the class A but display inline block and font size, they're different, so we get different classes. All the common styles are factored out for us, with you about it's hidden away behind the abstraction of generating the class names for us. So what that means when we generate our final bundle is that, when you compare style tron to other CSS and JS approaches, you get half the size of the bundle basically, because it is able to aggressively optimise down to the minimum set of combinations of property, value, and media query.
And just to be clear as well:  this is real-world CSS. This is from Airbnb. The best practice in terms of generating the smallest output of atomic CSS, it is baked in, not opt-in and we can only do this because it has close integration between the mark-up and our styles. The fourth point I think is where I really start to be sold on this idea, and that's around package management.
I want you to think about how we share CSS. We've been doing it for a long time. How do we do it?  You might think that we have had package managers are friendly to the front end, and that's true. Even when you're using package managers like MPM, when you're including CSS into your application from a third-party package, the inclusion step is generally a manual step, something that you have to go out of your way to wire in the application which is completely different from the code that you're installing. And I think the key reason why this is happening is because our CSS and the pack age managers that provide it are not coupled to a module system in the way that we've seen with MPM and common JS modules. When you think what happened what happens on MPM, for example, and how it deals with packages that have dependencies of dependencies of dependencies they're easily able to manage that fact, but with CSS it is not something we did do very well. We can't build CSS built up of other CSS. You see this trend with the different style of package managers. Bauer had this problem as well, all about flat fend seats, where MPM is a weapon of small dependencies, with , many libraries, playing out in the exponential growth in the number of packages being created.
When you have a flat set of dependencies like we've seen in the CSS community, what you have is monolithic dependencies, big, big libraries. This is what leads to things like in the older world of front-end single-page applications you might install jQuery, you might install Underscore, Backbone and then you were done. You didn't have a way to manage of more code than that. In the CSS world you would pick a framework like Tachyons and that was it. Where's our package manage for Sass for less?  We don't have one that is catered to that specific need that tackles it in the same way that we've seen elsewhere. But what I want you to do is to think about a little bit bit differently about the web platform and say where is the web pack age manager for HTML?  We already share helicopter a -- HTML a lot but we share it via JavaScript, so you install jQuery components, you install Backbone opponents, Angular directives, React components.  These are all encapsulating HTML in JavaScript which enables us to build and share on top of each other which wouldn't be possible if we were using static HTML. The question is what if we started sharing CSS via JavaScript and MPM in the same way?  Packaging up our CSS in the JavaScript in the way tell me rates are as well. Instead of mixins, we have functions that operate on plain data, strings and objects. Instead of extending ruling with , we use built-in syntax like the new object-spread syntax for spreading objects of rules together.
Now this means that we can compose and share our styles like any other code in our application and we can leverage package managers to do this. A good example of how this plays out is a really great library called polish. And polish is really the low dash of CSS and JS. It is a whole suite of utility functions for operating on CSS in a JavaScript environment but more importantly, it is not relegated to the style part of the application. You can use this anywhere. And this is particularly useful if you're doing things like building style guides and you want programmatically have logic behind CSS. This is a problem we face all the time where I work and having the problem solved in JavaScript neatly solves the problem. The hope is once you've moved towards expressing CSS in JavaScript, we can see open-source CSS look more like the MPM chart there where more and more styles are built on shared low-level functions, written and built upon and shared in a way that we haven't done before before and ironically enough, we can do this by embracing JavaScript modules, a module format widely supported today. The final point I want to cover is much more future-facing. This is not necessarily something that the CSS and JS community is particularly big on, but I think it is something that really is not possible today in the CSS community and it's really interesting, and that is non-browser styling. Like I said, I've been a big part of the React community, and React is really interesting for a number of reasons, but one of the big reasons is the fact that you don't deal with DOM manipulation directly, you deal with virtual DOM, a representation of what the final DOM will be rather than touching it directly. And what that it means  means is that when it comes time to render, you use a renderer for that environment you're dealing with. Here, when you render your React app on a server or client, you're pulling in something for React on, dealing with the DOM. The fact is that React core can have different renderers. You don't just have to target the DOM. It is not just virtual DOM, it is whatever the primitives are of the environment you're working in. You would have seen that play out with React native, something I'm sure you've all seen before, and that is about bringing this idea of bringing in virtual representations of the final components. In this case you're dealing with native components.
But what's interesting about React native is they wanted to make it friendly to people like us, web developers who know CSS in and out and it comes with its own style sheet instructions. Even though you're working in a native app, you style your app with what appears CSS. Here we are creating a style sheet with familiar properties, but what is really interesting about it is the fact that you can use Flexbox. This is an environment that's completely outside of a browser, doesn't natively have Flexbox and yet here we are using Flexbox in an iOS or Android application. The way they do this is by reimplementing Flexbox in JavaScript in CSS Lay-out and there was a massive test suite making sure they followed the spec correctly bringing Flexbox into their native apps. It's been formalised in a project called Yoga that is targeting a lot more environments. Now it is not written in JavaScript, it is written in C, targets C# and Objective-C as well. Yoga said their focus is on creating an expressive layout library, not implementing all of CSS. That might seem to be restrictive. If you think about our own work, managing CSS at scale is all about picking a reasonable subset of the language.  You think about BEM, you are deciding to not do all that CSS can do, but you do this to make your app more maintainable to unlock further abilities in your team, and to make your product more resilient over time.
So that means that if you're working in React native, you're not dealing with table layouts, floats, but dealing with Flexbox. Because we are dealing with  outside the environment, this makes our app more maintainable and portable. This unlocks the ability for us to have cross-platform components with embedded styles, styles that are targeted to the component that makes them available to different platforms. A really good example of what this allows us to do is React native web from Nicholas galler at Twitter. It allows us to have a drop in replacement where you can alias React native and everything you've written for the re act native app can run in a browser. A similar project along the same lines is React primitive. Recently we've seen funnily enough React XP from Microsoft which is a cross-platform component abstraction which again includes its own style sheet system.
But can we take our components even further?  Not all of us are building native apps. Is there much value beyond that?  We've seen a really interesting answer recently - I'm sure of you have seen this - React sketch-up by John Gold from Airbnb as well, and this to me is really key not just to the of components but future of design and how designers and developers interact, because what React sketch-up let's you do is write React code with style co-located with your components but render not into a native app or browser but into sketch. I'm sure most of you weren't aware that sketch has a JavaScript API or a Cocoa script API allowing you to run this code typically targeting designers. We can bridge that gap in a really interesting way. If, like me, you work day in, day out on design systems in the browser, this unlocks a really interesting potential of how we interact with our designers.
And we can do really interesting things like this:  here's a video that John posted which is showing responsive designs-style rendering into sketch all driven by code. This is only possible because we've been able to write our mark-up and our styles in a way that's portable outside of a browser. What we are looking at here is finally cross-platform, cross disciplinary design systems. We are having cross-platform crowed as the source of truth in our design systems, so instead of sketch being the source of truth, or Photoshop or pdf s, code is the source of truth but we can move the code back into an environment where the designers can also make use of it.
So, this has been a whirlwind tour of why people want to do CSS and JS or at least why you want to be interested in it at the very least. To recap all of this, it is about scoping our styles to the component so we can scale up to large systems and make them maintainable in a way that doesn't require so much careful hand-holding. It is about optimising our apps in ways we couldn't before and it is about taking our work and sharing it through package managers again in a way that we couldn't do before. It is about composing that applications out of the large shared code and build a community like we haven't been able to before and unifying on a portable platform that can target multiple environments. It is about moving us towards a unified styling language, and it's doing it in a way I never would have expected, and it's taken me a while to admit that this might very well be the of how we do styling for the web and beyond. This is what I'm bringing into my work day in, day out. I work a component system, and it's all about components. It is all about abstracting the styles behind a clean component interface, and I think this is the basis of how we are going to build better and better systems into the future.
Critically, I want to do this without breaking a progressive enhancement. I've come from a deep web background and I really love what the web platform provides and I think we can have the best of both worlds here.
So, when we think about learning CSS and we think about everything we've just seen, all of this stuff, nothing prevents you from the fact that you still have to learn CSS. You still have to learn CSS. That's where we all come in. The CSS and JS community is not done yet. There is still a whole lot of innovation happening, and that's where we need to get involved. Because there's a bunch of problems that are still being worked on, there's a lot of room for improvement, and the one library to rule them all has not been written yet. We are looking at improving performance, extracting static CSS hopefully as much as possible. We've seen people experiment with targeting CSS variables rather than targeting the web of several years ago. And finally, the most important thing, and I think this is where the people in this room can help the most of all, is making developers happy, because what we are seeing here is potentially the future of CSS tooling. And we want to make sure that we get it right. And I really hope that, from this, you take the message that this isn't as ridiculous as it sounds, it is actually some very sound thinking behind it, and your input is going to be really valuable and hopefully you've come around to the fact that there is something to this and something worth checking out. That is it from me. Thank you so much for listening. [Applause].
