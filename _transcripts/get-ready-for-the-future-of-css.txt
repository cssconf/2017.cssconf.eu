---
talk_id: get-ready-for-the-future-of-css
---

JESSICA: All right, next up we have Guil who is from Southern Florida, and I am actually originally from Georgia in the United States, and I was curious how many people here are representing the southern United States?  Wooh!  Interesting. We're all at the same table!  All right. Gill works at Treehouse, and they're really good at teaching people about things.
GUIL:   Thank you.
JESSICA:  Today, he's going to talk to us about the future of CSS. Is there art in the future?
GUIL:   Yes, lots of things. Put on our future glasses. I'm just getting set-up  set up with the internet here. Do you know what your first Tweet is?  I do.
GUIL:   It was seven years ago. It is so not me now. The University of Florida.
JESSICA:  Which is what tipped me off that obviously this person is from the same region of the country that I am from!  All right, are you ready?  Is that working?  Give it up for Guil!  [Applause].
GUIL:   Thanks so much everyone, good afternoon. Thanks so much for having me here. It is the first time in Berlin in Germany. I had a great teem meeting a lot of you and learning so much from some of the attendees here. I'm heroin herb heroin coming to - I'm Guil Henandez. We are an online technology school. I teach courses with CSS, JavaScript and most recently React. You can find me on the Twitter as  and most places on the internet and I love CSS. That's why I'm here. That's one of my favourite subjects to teach and talk about. Today I will be talking about some of the more fascinating things happening in CSS now because CSS now provides some really amazing tools, right, that empower us, more than ever before and gives us more flexibility over things like design, images effects, design, layout colours - even managing and reusing values, right?  So, if you haven't started using or looking to these teachers yet, I'm going to cover just enough to get you using them and help you begin leveraging these features to empower your work flows. We are going to be looking at a little bit of code and lots of  demos in the next 30 minutes or so. I'm going to post the slides after the talk. For timing reasons, I will not go into too much about browser support. There will be a resources slide with some links to that.
So, let's kick things off by talking about CSS variables, AKA custom properties. We know that CSS can be immensely repetitive and maintaining it can be cumbersome. If you're using a pre-processor like Sass, you're used to declaring variables and keeping track of variables in your style sheets. As we all kind know, you can have variables directly in CSS and pre-processors, and they hold references to values that you can reference in your style sheets. They are formerly known as custom properties, because you declare them using a new custom properties syntax means you can name them anything you want as long as you prefix them with the values. For example, if you are repeating the same colour value in different places, you can create a variable of that, so say your font size or base colour. You repeat it like you would a regular CSS property. They follow the rules of the cascade, so you first have to declare them and you will often declare variables that will be referenced by many elements like your base colour or based on size on the root, right?  So you have to scope them to an let, usually the root, and that scopes them at the highest level of the cascade - that way the values are available everywhere, and they can be referenced and inherited by all elements. The browser doesn't do anything with a custom property. To call the value, you have to use the bar function - the VAR function. Every time you change the value, the constant property, it gets propagated and passed down to along wherever it's being used, and it makes your CSS work flow a little less error-prone and easier, right?  A property value can contain more than one var function like seen here, two bars to define the gradient. It is possible to assign a value to a custom property like this gradient here. You can them for font stacks and layout styles. This isn't terribly exciting. Just stay there because we've been able to do this for some time with Sass and other in post-CSS. Custom properties weren't meant to be the pre-processor equivalent or offer the same functionality. They can do lots and lots of things that pre-processors can't. Let's look at why. Pre-processors in CSS variables are like two different entities. It is like they live in two completely different worlds. First pre-processors don't run in the browser, and they live in a force file on the machine, right?  The pre-processors replace variables with static values and they're compiled to CSS. The browser knows nothing about the variables and the variables themselves know nothing about your DOM structure. On the other hand, CSS variables are entirely more flexible than pre-processor variables, so, when you update the value of a CSS variable the browser updates it and it does it at run time. This makes it incredibly dynamic and it opens up lots of other interesting probabilities. In Sass, you can't update the value of a variable from within a media enquiry but you can with CSS variable. We have this gutter variable here initially scoped to the root element and referenced to the gutter. Then you can use media queries to provide the new context that redefines the value of the gutter at certain break points. You can see that gutter property, the values are updated by each break point. The values themselves are responsive to them. Now, CSS custom properties or variables, they behave like regular properties, so it means they can inherit, cascade and scoped to any selector. Here we have this base button class used as the variable to set the background colour and then instead of defining that button variable at the root scope like we did earlier, we can declare it on different selectors like button modifier here, and then we assign the values there, and those selectors provide a new scope.
And, what is great is that the properties, they get resolved according to the normal and inheritance cascading rules, so the browser updates the values of that button just based on the class for the DOM element the variables scope to. You can even update CSS variables inline within the style attribute. That's how live they are in the browser. So scoping CSS variables to DOM elements gives us even more interesting possibilities since they follow the cascade and inheritance. We could stop them based on where they appear in the DOM, so in other words we can officially set how an element looks when it's inside another element with variables. For example, to update the styles of a button component based on whether it appears inside a banner, a card, or a modal class, you might create descendent selectors to do this. With CSS updates we can select the styles or not having to write the descendent selectors. This makes the components you build completely extensible, right, so now the button can display different font size, colour, grabbing ground or any property based on where it appears in the page and the CSS variable declared on its parent. Here, this button rule, the CSS properties whose values we want to up date dynamically with variables, and then to change how that button appears, inside a banner, a modal, you declare the different variables inside the selectors. Any button class descendent of barn can inherit these properties. The best part is they don't have to know anything about their context. We get this perfectly button. You can also do simple calculations with CSS variable. Here, a handy-use case is using the calc function to determine the length function. This is variables to build pixel ... the variables can't only be updated using inheritance. As you saw earlier, you can interact with them using JavaScript. You can get and set CSS values from your JavaScript and that's where things start to get really interesting. In the simple demo, we had the ball moving around the page. It's based where you click on the page. The background colour and the CSS transform properties are all being updated via JavaScript. And the way you interact with the CSS variables with JavaScript is with the get-property value and the set-property methods. So back to the ball animation. This uses variables to set the value for the background colour and the x, x translation values being calculated with calc and in JavaScript it is able to set the background colour and those translation values with the set property method. Here we're just setting the values, not getting them. For example, a click event listener, setting the values to the x and y co-ordinate where the clicking happens and then to change the background colour value, it is setting that property with a helper function there. So now that you've seen how and where CSS variables work, you should know where they do not work. You cannot use CSS variables in selectors. You can't use them in property names, either. You can only use them in values. They're also not valid in media query expressions which is kind of a bummer - I wish they were. Again, you should use calc to build your length values using CSS variables. Cool. Let's switch gears here. The evolution of CSS keeps providing more and more ways to help us make creative decisions in the browser, because many of today's features resemble a lot of tools you would normally use in your graphics editor, so blend modes, for example, you might have worked with some of these. They are part of the compositing and blending and CSS - "compositing" meaning combining two or more elements into one like compositing an image and its backdrop, calculating colours where the background overlaps and defines how the colours in overlapping areas and CSS gives us two properties to create and blend elements together, so we have background blend mode, mixed blend mode and let's take a look at some of these. The back ground blends an element with a background layer and the background can be an image, a gradient, it can be a colour. For example, here, we are blending a background image with a linear gradient and giving it a multiplier which is a common value for that. Multiply modifies the background area by multiplying the colour in the image which the colours of the linear gradient and in this particular combination makes for a more vibrant and beautiful background image, right. You will find that the background options are very similar to ones you would find in Photoshop. You have screen overlay, dark and saturation, and a bunch more. Mix-blend mode is a little different in that it blends the content of an svg or HTML element with any content that's painted underneath it, so we're not limited to background areas. That means you can blend or composite two or more embedded images together, so, for example, here this image inside a header that has a dark background area. CSS can seamlessly blend them together which we want to lighten because of that dark area. Now, when I find out that you could blend an image element with a background layer, I started using mixed-blend mode to help give my images some life, and colour and create custom sets of colours for images. For example, this image. I did have to place it in a different containing element to do this, but you can give that div or containing element a background colour or gradient and then use multiply to blend it together with the background of its parent. Grey scale images tend to have smaller file sizes than colour images and you can take advantage of that and use grey scale to apply pretty much any series of colours to your images. You could also do this with svg, use the image element to render a raster image, and in this way, you avoid writing some of the extra CSS required to make that image fit inside the div.  Here's another of mixed-blend mode being used to create that knock-out text effect. I animated the background so you can really see that the true blending and compositing power of mixed-blend mode. Another one of my favourite news image, it's not blending and compositing, it is the level two spec is backdrop filter. If you've worked with CSS filters, you know that you can apply a series of these filter-like effects to HTML elements. You can have grey scale contrast and invert in a bunch of others, well, the backdrop filter property lets you add some of the same effect to the area behind an element, right?  So, the way this works it needs at least two elements to work properly, this the backdrop filter, so you need a target element that you apply the filter to, like our filter rule here. And then you need an element behind or underneath the target, and that's the backdrop area that's going to be affected by - and you apply the filter effects. This is setting the backdrop filter to invert the colours by 100 per cent and blend them by two pixels, so any area behind that. I made this draggable. So yes, so that is the filter element here. If you take a look at this later, you can see the colours in the background. Here we go. I was doing it here. There it is.  The colours are inverting. The backdrop filters can also enhance the modals in your design. For instance, this overlay box there is a filter behind it that blurs the background area and draws more attention to the overlay box in the content. They are animatable, too. You have a gallery or product page where you need to click to expand something. Backdrop filter can enhance that and make it more interesting. Here, it is blurring the background and adjusting the hue when the image scale is out. Being able to apply these blending and filtering effects to HTML elements with CSS gives us a lot of power and flexibility when we are designing and building our projects. In a similar vein, one feature that is letting us break out of the rectangular nature displayed on the web is CSS shapes because our shapes consist of polygons and circles and shapes allows us a way new way how our content flows on the page. We can use geometric shapes and have text flow around the shapes. The shapes feature works only on floated element using the new shape property, so we can take this circle or image here, float it left in our design and then define a shape outside property to turn on the shapes feature, that's what makes it work. And then the value, you see here the circle function, that's the new function that's going to create the CSS shape. It is a, for example, it's going to set the inline text to flow around the circular shape of the image. That's pretty neat, but what is interesting is that you can also leverage the box model and use regular box model key word values to flow content around a circle or image, for example,. The image already uses a border radius to create that circle or effect, so, instead of having the browser do a little bit of extra work to redefine a circular shape, you can set shape outside to border box, so you're pretty familiar with that. Then the text will follow the outer images's circular border.  The way you apply a margin when you're using the box model key word values is with the new shape-merging property, for example, here, we are sending it to 20 pixels, and this is a new property of the shapes module.
The Polygon function will give you unlimited shape possibilities in your design, right?  You create a shape by defining the x, y co-ordinates for each point in the Polygon. You can set the text to flow around the right edge of a triangle giving you three Polygon points. You can see it wrapping around edge. I define multiple polygon points to set the heading in paragraph to flow around the con tours. You can use the handy CSS shapes editor tool - it is a chrome extension - to create this and a lot of the shapes I experiment with with poll y gone. It is an interactive shapes editor that lets you - how the text will flow around the shapes you set.  A feature that works very well along side Shapes is the clip pad. Clipping is a long-time feature of graphic design. That is used to partially or fully hide parts of a graphic. Since CSS, the clip path property lets you clip portions of an HTML element. We're not limited to regular tang similar clipping paths, able to draw clipping regions, with basic shapes, even with svgs. We use the clip-path property which will create a clipping region setting the visible portions of an element. You can move the background portions of the image and design. For example, this dark area here. We are giving clip path the circle property - it is a circle function - and that's one of the basic shape functions that will define a clipping path. So now, any part outside of that clipping region, they become hidden or clipped to reveal the circular image. Using what - what is great using clip-path in CSS Shapes, they work hand in hand. You can reuse your clip-path values to define a shape around your clipping path. They use both exactly the same syntax. For example, here we are providing the shape outside property, the exact same function flowing text around that region.
It looks really wide there. In your mark-up, you can also do this with svg, so you use the clip-path svg element inside it. In your CSS you can reference the clip path function and then you call up the clip-path ID. That could produce something like this. So this is a heading with a div, with a background image. The Polygon points follow the exact shape of the mountain-top and as a result those portions get clipped and clip out the bottom parts of the text. To help you set clipping paths, Ben built Clippy and you can use the tool to create clip paths, shapes or just simply experiment with what CSS clip path can do for you. We've seen that trendy effect, on websites and applications. I've seen it done with pseudo elements and transforms, with svgs, with an image. With a tool like Clippy, you can create it quickly. Create the shapes, then copy and paste the code that spits out into your CSS, for example, the header rule. You get that visual effect, and what is great is, when you use percentage-based co-ordinates, it's going to give you flexible and responsible clipping paths.  Colour module level 4 will give you new ways to apply. You will have new colour functions that let I adjust and modify colours. You're going to have new values for setting the opacity of colours. One is eight-digit helpful notation allowing you to set channels as regular hexadecimal values, in other words, you get to do alpha in text by tacking on digits on the value. The last two digits represent the alpha. 00 gives you a fully transparent colour and "FF" represents the fully opaque colour. It uses the regular hexadecimal system to define the alpha.  If you're used to defining your values in RGBA or HSLA, you will find it can be a little unintuitive at first. If you want to set a 50 per cent transparency, you're going to use 80, not 50. 20 is 33, and so on. There are some charts out there that you can use as a reference for eight-digit x values for alpha, and one of the best places to use these are in places where you've already defined helpful values and you want to add opacity to it or if you hurt using helpful values in general, those two digits might save you time. Browser support for eight-digit helpful is currently limited to Firefox and Safari, but you can also use it in Chrome if you've enable to the experimental web platform features. Not all helpful RGB values are easy to remember. If you're writing plain CSS, changing or adjusting a colour value often means having to reference your graphics editor or colour tool, and pre-processors already offer colour functions that can apply transparency to colours, has function that is can lighten them and blend them. CSS is going to get a colour modification of its own. The new colour mod function will let you manipulate colours by letting you take a regular colour volume and applying colour adjustors to it. It is like smaller functions within colour mod that, for example, can adjust the colour's hue, lightness, and lots, lots more. Now, the spec for this function is fill a work in draft, so it doesn't have good browser support yet, but you can use it in post-CSS, it has a colour function which works exactly the way colour mod function was meant to work. It was renamed colour mod and you can begin experimenting with it in CodePen.  So let's take a look at how some of those work. We have a lightness adjustor here, and that lightens a colour value by a specified amount, for example, 20 per cent here, you can also take away lightness by settle a negative percentage value, but the best part is you can pass two or more adjustors to your colour-mod function so alongside alpha and lightness, the hue adjustor here changes the hue of a colour by rotating the colour wheel by the specified amount, so, for example, by five degrees here.  Now if you throw CSS variables into the mix, you can start to hey  see how useful the colour-mod function can be for creating colours from a single base colour. We are we have on a set of colour variables and set from crimson and using adjustors like hue and lightness and even getting the complementary colours. You can change the base colour to any value, like cornflower blue, hot pink. The result is a completely different colour combination each time.  So having a way to quickly explore and manipulate colours on the fly while working in the browser, a simple intuitive function is going to be a huge one for CSS. There is a really neat tool out there called colourme.io where you can experiment with the colour functions and adjustors.
Cool. Let's keep moving. So selectors level 4. There are lots and lots of new selectors on the way in level 4. Many are not scored by browsers yet because it is still a working draft. Now, I will spend a little bit of time covering some of the selectors that I have found useful, just in my own work, and some that have the most browser support. One of those is matches. Matches is a function al pseudo-class and will help you write complex selectors a lot faster. It really just provides a little syntactic sugar for creating groups of descendent, direct-child even sibling - matches takes regular selectors as argument. So, for example, here, the selector is going to match any button class that's a descendent of card, modal, and form, and it is the same as writing the full selector group you see there below it. You can also pass pseudo classes, so this is going to make it a lot easier to, for example, style your links. This is targeting the hover focus all at once, and, inside matches, you can pass pseudo elements and you can create - outside that argument list. For instance, this is going to match any paragraph that's aegis sent sibling of image, paragraph and form, and as you can see, just is saves you a little time to avoid writing out the selector combinations manually. If you do a search for browser support, it is implemented under the name "any" as it was originally known and will be standard under level 4 under the name "matches". There's a new optionality for pseudo classes that targets controls like text fields, area and select and targets them based on whether they're optional or required so you can style them differently. The ones that I really enjoyed using and had fun in my own work with the validity pseudo classes letting you give your users visual feedback, so, for example, if you have an email input field that's required, you can define invalid and valid pseudo classes that style based on what the user types into the field, so here it checks it, if you've entered a valid email format, for example,. At pseudo - add pseudo elements to the mix and it can be really useful. It gives you even more visual feedback, like you can display an icon when the data goes from invalid to valid. Displaying that smiley emoji, for example,. Talk I can things a few steps further and display valid and invalid emails. Normally, you will use JavaScript to do something like this, but with CSS you get the input texts for tree. It won't check ifle email itself is a valid email but validates the input to the validity semantics defined by HTML. There are a few sites out there that can help you keep track on browser support for these level-four selectors if you don't want to individually search for them on www.caniuse.com to see if your browser supports them, it will let you know. Some of the features I talked about are new to producers. They're not supported everywhere but that should not mean that you can't use them or at least begin experiment be with them. You're still able to use a lot of them today while providing the elegant fallbacks. So the at-support rule is bringing native feature detection to CSS so it can analyse whether or not a browser supports a CSS property and it looks like a lot like a media query. This is querying for grid layout and is - so, then inside the rule, we are inside the supports rule, we are including all the grid styles for the content, and then Flexbox currently has better support than Grid, right, so the browsers that don't support grid layout are going to lay out the content using the Flexbox properties defined outside the feature query, so it's like having moderniser which is a feature detection tool bit in JavaScript but right in the browser it's going to form a lot faster. For example, up here up top we have the and operator checking for grid and writing mode support and writing mode is also a new CSS property that changes the layout. Some browser supporting both features, users will see something like this. And browsers that don't support these will simply display a normal heading in paragraph which is not a big deal, and as you can there, they have really good browser support, the feature queries do, and the supports. Browsers that don't support these feature queries, they're going to ignore what is written inside the support rule and just fall back to your regular CSS. Finally, here is the list of browser support links I talked about earlier that covers all the features I talked about today, and, yes, as with almost anything in front-end web development and web development there are so many features and factors to consider when building a project, so many of the things I've covered are really enhancement features, so you don't want to overdo it and you want to be sure that your design and content still speaks to your users, even with some of these features in place. Hopefully, what I talked about today gives you lots of interesting new ideas for your next projects, and, as I always tell students at Treehouse, use all the guidelines and suggestions and the things that you have learned and see.
Just find out what works best for you in your project and team. You don't have to immediately use the new things and use everything because they are popular at the moment. A lot of it is a matter of preference. The important thing is develop your own approach approach and style and be consistent. That's all I have for you today. Thanks a lot. [Applause].
